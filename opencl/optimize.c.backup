/*
 * OpenCL GPU-accelerated trading strategy optimizer
 * Usage: ./optimize <TICKER> <INTERVAL>
 * Example: ./optimize GOOG 1h
 * 
 * Compilation:
 *   make
 */

#ifdef __APPLE__
#include <OpenCL/opencl.h>
#else
#include <CL/cl.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <ctype.h>

// Strategy selection via compiler flag -DSTRATEGY_DIR="adaptive_ema_v1"
#ifndef STRATEGY_DIR
#define STRATEGY_DIR "adaptive_ema_v1"
#endif

// Macro to build include paths dynamically
#define INCLUDE_PATH(file) <strategies/STRATEGY_DIR/file>
#define STR(x) #x
#define XSTR(x) STR(x)
#define STRATEGY_FILE(base, ext) "strategies/" STRATEGY_DIR "/" base ext

// Include strategy config files based on selected strategy
#include STRATEGY_FILE("config_1h", ".h")
#include STRATEGY_FILE("config_4h", ".h")
#include STRATEGY_FILE("config_1d", ".h")

typedef struct {
    int fast_length_low_min, fast_length_low_max;
    int slow_length_low_min, slow_length_low_max;
    int fast_length_med_min, fast_length_med_max;
    int slow_length_med_min, slow_length_med_max;
    int fast_length_high_min, fast_length_high_max;
    int slow_length_high_min, slow_length_high_max;
    int atr_length_min, atr_length_max;
    int volatility_length_min, volatility_length_max;
    int low_vol_percentile_min, low_vol_percentile_max;
    int high_vol_percentile_min, high_vol_percentile_max;
} Config;

// Load configuration based on interval
void load_config(const char* interval, Config* config) {
    // Now reads from strategy config headers (config_1h.h, config_4h.h, config_1d.h)
    // Edit those files to change parameters instead of editing this file!
    
    if (strcmp(interval, "1h") == 0) {
        #ifdef USE_PERCENT_RANGE_1H
            float percent = SEARCH_PERCENT_1H;
            int default_fast_low = FAST_LOW_1H;
            int default_slow_low = SLOW_LOW_1H;
            int default_fast_med = FAST_MED_1H;
            int default_slow_med = SLOW_MED_1H;
            int default_fast_high = FAST_HIGH_1H;
            int default_slow_high = SLOW_HIGH_1H;
            int default_atr = ATR_LENGTH_1H;
            int default_vol = VOL_LENGTH_1H;
            int default_low_pct = LOW_VOL_PCT_1H;
            int default_high_pct = HIGH_VOL_PCT_1H;
            
            config->fast_length_low_min = (int)(default_fast_low * (1 - percent));
            config->fast_length_low_max = (int)(default_fast_low * (1 + percent));
            config->slow_length_low_min = (int)(default_slow_low * (1 - percent));
            config->slow_length_low_max = (int)(default_slow_low * (1 + percent));
            config->fast_length_med_min = (int)(default_fast_med * (1 - percent));
            config->fast_length_med_max = (int)(default_fast_med * (1 + percent));
            config->slow_length_med_min = (int)(default_slow_med * (1 - percent));
            config->slow_length_med_max = (int)(default_slow_med * (1 + percent));
            config->fast_length_high_min = (int)(default_fast_high * (1 - percent));
            config->fast_length_high_max = (int)(default_fast_high * (1 + percent));
            config->slow_length_high_min = (int)(default_slow_high * (1 - percent));
            config->slow_length_high_max = (int)(default_slow_high * (1 + percent));
            config->atr_length_min = (int)(default_atr * (1 - percent));
            config->atr_length_max = (int)(default_atr * (1 + percent));
            config->volatility_length_min = (int)(default_vol * (1 - percent));
            config->volatility_length_max = (int)(default_vol * (1 + percent));
            config->low_vol_percentile_min = (int)(default_low_pct * (1 - percent));
            config->low_vol_percentile_max = (int)(default_low_pct * (1 + percent));
            config->high_vol_percentile_min = (int)(default_high_pct * (1 - percent));
            config->high_vol_percentile_max = (int)(default_high_pct * (1 + percent));
        #else
            fprintf(stderr, "‚ö†Ô∏è  Warning: Fixed range mode not implemented. Enable USE_PERCENT_RANGE_1H in config_1h.h\n");
            exit(1);
        #endif
    } else if (strcmp(interval, "4h") == 0) {
        #ifdef USE_PERCENT_RANGE_4H
            float percent = SEARCH_PERCENT_4H;
            int default_fast_low = FAST_LOW_4H;
            int default_slow_low = SLOW_LOW_4H;
            int default_fast_med = FAST_MED_4H;
            int default_slow_med = SLOW_MED_4H;
            int default_fast_high = FAST_HIGH_4H;
            int default_slow_high = SLOW_HIGH_4H;
            int default_atr = ATR_LENGTH_4H;
            int default_vol = VOL_LENGTH_4H;
            int default_low_pct = LOW_VOL_PCT_4H;
            int default_high_pct = HIGH_VOL_PCT_4H;
            
            config->fast_length_low_min = (int)(default_fast_low * (1 - percent));
            config->fast_length_low_max = (int)(default_fast_low * (1 + percent));
            config->slow_length_low_min = (int)(default_slow_low * (1 - percent));
            config->slow_length_low_max = (int)(default_slow_low * (1 + percent));
            config->fast_length_med_min = (int)(default_fast_med * (1 - percent));
            config->fast_length_med_max = (int)(default_fast_med * (1 + percent));
            config->slow_length_med_min = (int)(default_slow_med * (1 - percent));
            config->slow_length_med_max = (int)(default_slow_med * (1 + percent));
            config->fast_length_high_min = (int)(default_fast_high * (1 - percent));
            config->fast_length_high_max = (int)(default_fast_high * (1 + percent));
            config->slow_length_high_min = (int)(default_slow_high * (1 - percent));
            config->slow_length_high_max = (int)(default_slow_high * (1 + percent));
            config->atr_length_min = (int)(default_atr * (1 - percent));
            config->atr_length_max = (int)(default_atr * (1 + percent));
            config->volatility_length_min = (int)(default_vol * (1 - percent));
            config->volatility_length_max = (int)(default_vol * (1 + percent));
            config->low_vol_percentile_min = (int)(default_low_pct * (1 - percent));
            config->low_vol_percentile_max = (int)(default_low_pct * (1 + percent));
            config->high_vol_percentile_min = (int)(default_high_pct * (1 - percent));
            config->high_vol_percentile_max = (int)(default_high_pct * (1 + percent));
        #else
            fprintf(stderr, "‚ö†Ô∏è  Warning: Fixed range mode not implemented. Enable USE_PERCENT_RANGE_4H in config_4h.h\n");
            exit(1);
        #endif
    } else { // 1d
        #ifdef USE_PERCENT_RANGE_1D
            float percent = SEARCH_PERCENT_1D;
            int default_fast_low = FAST_LOW_1D;
            int default_slow_low = SLOW_LOW_1D;
            int default_fast_med = FAST_MED_1D;
            int default_slow_med = SLOW_MED_1D;
            int default_fast_high = FAST_HIGH_1D;
            int default_slow_high = SLOW_HIGH_1D;
            int default_atr = ATR_LENGTH_1D;
            int default_vol = VOL_LENGTH_1D;
            int default_low_pct = LOW_VOL_PCT_1D;
            int default_high_pct = HIGH_VOL_PCT_1D;
            
            config->fast_length_low_min = (int)(default_fast_low * (1 - percent));
            config->fast_length_low_max = (int)(default_fast_low * (1 + percent));
            config->slow_length_low_min = (int)(default_slow_low * (1 - percent));
            config->slow_length_low_max = (int)(default_slow_low * (1 + percent));
            config->fast_length_med_min = (int)(default_fast_med * (1 - percent));
            config->fast_length_med_max = (int)(default_fast_med * (1 + percent));
            config->slow_length_med_min = (int)(default_slow_med * (1 - percent));
            config->slow_length_med_max = (int)(default_slow_med * (1 + percent));
            config->fast_length_high_min = (int)(default_fast_high * (1 - percent));
            config->fast_length_high_max = (int)(default_fast_high * (1 + percent));
            config->slow_length_high_min = (int)(default_slow_high * (1 - percent));
            config->slow_length_high_max = (int)(default_slow_high * (1 + percent));
            config->atr_length_min = (int)(default_atr * (1 - percent));
            config->atr_length_max = (int)(default_atr * (1 + percent));
            config->volatility_length_min = (int)(default_vol * (1 - percent));
            config->volatility_length_max = (int)(default_vol * (1 + percent));
            config->low_vol_percentile_min = (int)(default_low_pct * (1 - percent));
            config->low_vol_percentile_max = (int)(default_low_pct * (1 + percent));
            config->high_vol_percentile_min = (int)(default_high_pct * (1 - percent));
            config->high_vol_percentile_max = (int)(default_high_pct * (1 + percent));
        #else
            fprintf(stderr, "‚ö†Ô∏è  Warning: Fixed range mode not implemented. Enable USE_PERCENT_RANGE_1D in config_1d.h\n");
            exit(1);
        #endif
    }
}

// Load CSV data (you'll need to fetch this via Python first)
int load_csv(const char* filename, float** closes, float** highs, float** lows, long long** timestamps) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "‚ùå Error: Could not open %s\n", filename);
        fprintf(stderr, "   Run: python3 ../c/fetch_data.py %s\n", filename);
        return -1;
    }
    
    // Count lines
    int count = 0;
    char line[1024];
    fgets(line, sizeof(line), file); // Skip header
    
    while (fgets(line, sizeof(line), file)) {
        count++;
    }
    
    rewind(file);
    fgets(line, sizeof(line), file); // Skip header again
    
    *closes = malloc(count * sizeof(float));
    *highs = malloc(count * sizeof(float));
    *lows = malloc(count * sizeof(float));
    *timestamps = malloc(count * sizeof(long long));
    
    int i = 0;
    while (fgets(line, sizeof(line), file) && i < count) {
        long long timestamp;
        float open, high, low, close, volume;
        sscanf(line, "%lld,%f,%f,%f,%f,%f", &timestamp, &open, &high, &low, &close, &volume);
        
        // Round to 4 decimal places for better GPU performance
        // Stock prices rarely need more precision than $0.0001
        (*closes)[i] = roundf(close * 10000.0f) / 10000.0f;
        (*highs)[i] = roundf(high * 10000.0f) / 10000.0f;
        (*lows)[i] = roundf(low * 10000.0f) / 10000.0f;
        (*timestamps)[i] = timestamp;
        i++;
    }
    
    fclose(file);
    return count;
}

// Load OpenCL kernel from file
char* load_kernel_source(const char* strategy_dir) {
    char kernel_path[512];
    snprintf(kernel_path, sizeof(kernel_path), "strategies/%s/kernel.cl", strategy_dir);
    
    FILE* file = fopen(kernel_path, "r");
    if (!file) {
        fprintf(stderr, "‚ùå Error: Could not open kernel file: %s\n", kernel_path);
        fprintf(stderr, "   Make sure the strategy directory exists with kernel.cl\n");
        exit(1);
    }
    
    // Get file size
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    // Allocate and read
    char* source = (char*)malloc(file_size + 1);
    if (!source) {
        fprintf(stderr, "‚ùå Error: Could not allocate memory for kernel source\n");
        fclose(file);
        exit(1);
    }
    
    size_t read_size = fread(source, 1, file_size, file);
    source[read_size] = '\0';
    
    fclose(file);
    
    printf("‚úÖ Loaded kernel from: %s (%ld bytes)\n", kernel_path, file_size);
    return source;
} 
"__kernel void optimize_strategy(\n"
"    __global const float* closes,\n"
"    __global const float* highs,\n"
"    __global const float* lows,\n"
"    int num_candles,\n"
"    __global const float* params,\n"
"    __global float* results,\n"
"    int num_combinations,\n"
"    __global float* trade_log\n"
") {\n"
"    int idx = get_global_id(0);\n"
"    if (idx >= num_combinations) return;\n"
"    \n"
"    // Extract parameters for this combination\n"
"    int param_offset = idx * 10;\n"
"    int fast_low = (int)params[param_offset + 0];\n"
"    int slow_low = (int)params[param_offset + 1];\n"
"    int fast_med = (int)params[param_offset + 2];\n"
"    int slow_med = (int)params[param_offset + 3];\n"
"    int fast_high = (int)params[param_offset + 4];\n"
"    int slow_high = (int)params[param_offset + 5];\n"
"    int atr_length = (int)params[param_offset + 6];\n"
"    int vol_length = (int)params[param_offset + 7];\n"
"    int low_pct = (int)params[param_offset + 8];\n"
"    int high_pct = (int)params[param_offset + 9];\n"
"    \n"
"    // Validate parameter constraints\n"
"    if (fast_low >= slow_low || fast_med >= slow_med || fast_high >= slow_high || low_pct >= high_pct) {\n"
"        results[idx * 5 + 4] = 0.0f;  // Mark as invalid\n"
"        return;\n"
"    }\n"
"    \n"
"    // Pre-calculate ATR\n"
"    float atr_values[1024]; // Assume max candles < 1024\n"
"    float alpha_atr = 2.0f / (atr_length + 1.0f);\n"
"    float atr = 0.0f;\n"
"    \n"
"    for (int i = 1; i < num_candles; i++) {\n"
"        float tr = fmax(highs[i] - lows[i], fmax(fabs(highs[i] - closes[i-1]), fabs(lows[i] - closes[i-1])));\n"
"        if (i == 1) {\n"
"            atr = tr;\n"
"        } else {\n"
"            atr = alpha_atr * tr + (1.0f - alpha_atr) * atr;\n"
"        }\n"
"        if (i >= atr_length) {\n"
"            atr_values[i] = atr;\n"
"        }\n"
"    }\n"
"    \n"
"    // Trading state\n"
"    float capital = 10000.0f;\n"
"    float position = 0.0f;\n"
"    float max_capital = capital;\n"
"    float max_drawdown = 0.0f;\n"
"    int trades = 0;\n"
"    \n"
"    // Backtest loop\n"
"    for (int i = vol_length + 1; i < num_candles; i++) {\n"
"        // Determine volatility regime\n"
"        float current_atr = atr_values[i];\n"
"        int count = 0;\n"
"        for (int j = i - vol_length; j < i; j++) {\n"
"            if (atr_values[j] < current_atr) count++;\n"
"        }\n"
"        float rank_pct = (float)count / vol_length * 100.0f;\n"
"        \n"
"        int regime = 1; // 0=low, 1=med, 2=high\n"
"        if (rank_pct < low_pct) regime = 0;\n"
"        else if (rank_pct > high_pct) regime = 2;\n"
"        \n"
"        // Select EMA lengths based on regime\n"
"        int fast_len, slow_len;\n"
"        if (regime == 0) {\n"
"            fast_len = fast_low;\n"
"            slow_len = slow_low;\n"
"        } else if (regime == 2) {\n"
"            fast_len = fast_high;\n"
"            slow_len = slow_high;\n"
"        } else {\n"
"            fast_len = fast_med;\n"
"            slow_len = slow_med;\n"
"        }\n"
"        \n"
"        // Calculate EMAs (simplified, assuming pre-warm)\n"
"        float alpha_fast = 2.0f / (fast_len + 1.0f);\n"
"        float alpha_slow = 2.0f / (slow_len + 1.0f);\n"
"        \n"
"        // For simplicity, calculate EMAs on the fly (not optimal, but works)\n"
"        float ema_fast = closes[i - fast_len];\n"
"        float ema_slow = closes[i - slow_len];\n"
"        for (int k = i - fast_len + 1; k <= i; k++) {\n"
"            ema_fast = alpha_fast * closes[k] + (1.0f - alpha_fast) * ema_fast;\n"
"        }\n"
"        for (int k = i - slow_len + 1; k <= i; k++) {\n"
"            ema_slow = alpha_slow * closes[k] + (1.0f - alpha_slow) * ema_slow;\n"
"        }\n"
"        \n"
"        // Entry signal: Fast EMA crosses above Slow EMA\n"
"        if (position == 0.0f && ema_fast > ema_slow && i > 50) {\n"
"            position = capital / closes[i];\n"
"            capital = 0.0f;\n"
"            \n"
"            // Log trade for first parameter set only\n"
"            if (idx == 0 && trades < 100) {\n"
"                trade_log[trades * 3 + 0] = (float)i;      // Candle index\n"
"                trade_log[trades * 3 + 1] = closes[i];     // Entry price\n"
"                trade_log[trades * 3 + 2] = 1.0f;          // Buy signal\n"
"            }\n"
"            trades++;\n"
"        }\n"
"        // Exit signal: Fast EMA crosses below Slow EMA\n"
"        else if (position > 0.0f && ema_fast < ema_slow) {\n"
"            capital = position * closes[i];\n"
"            \n"
"            if (idx == 0 && trades < 100) {\n"
"                trade_log[trades * 3 + 0] = (float)i;\n"
"                trade_log[trades * 3 + 1] = closes[i];\n"
"                trade_log[trades * 3 + 2] = 0.0f;          // Sell signal\n"
"            }\n"
"            position = 0.0f;\n"
"            trades++;\n"
"        }\n"
"        \n"
"        // Track drawdown\n"
"        float current_value = capital + position * closes[i];\n"
"        if (current_value > max_capital) max_capital = current_value;\n"
"        float drawdown = (max_capital - current_value) / max_capital * 100.0f;\n"
"        if (drawdown > max_drawdown) max_drawdown = drawdown;\n"
"    }\n"
"    \n"
"    // Close any open position\n"
"    if (position > 0.0f) {\n"
"        capital = position * closes[num_candles - 1];\n"
"    }\n"
"    \n"
"    // Calculate performance metrics\n"
"    float total_return = (capital - 10000.0f) / 10000.0f * 100.0f;\n"
"    \n"
"    // Filter invalid results\n"
"    if (trades < 2 || max_drawdown > 50.0f || !isfinite(total_return)) {\n"
"        results[idx * 5 + 4] = 0.0f;\n"
"    } else {\n"
"        float calmar = max_drawdown > 0 ? total_return / max_drawdown : 0.0f;\n"
"        \n"
"        // Store results\n"
    printf("‚úÖ Loaded kernel from: %s (%ld bytes)\n", kernel_path, file_size);
    return source;
}

void check_error(cl_int err, const char* operation) {
    if (err != CL_SUCCESS) {
        fprintf(stderr, "Error during %s: %d\n", operation, err);
        exit(1);
    }
}

int main(int argc, char** argv) {
    if (argc != 3) {
        printf("Usage: %s <TICKER> <INTERVAL>\n", argv[0]);
        printf("Example: %s GOOG 1h\n", argv[0]);
        printf("\nIntervals: 1h, 4h, 1d\n");
        printf("\nCurrent strategy: %s\n", STRATEGY_DIR);
        printf("To change strategy, recompile with: make STRATEGY=adaptive_ema_v2\n");
        return 1;
    }
    
    char* ticker = argv[1];
    char* interval = argv[2];
    
    // Convert to uppercase
    for (char* p = ticker; *p; p++) *p = toupper(*p);
    for (char* p = interval; *p; p++) *p = tolower(*p);
    
    printf("\n");
    printf("üéÆ OpenCL GPU Parameter Optimization System\n");
    printf("   Ticker: %s\n", ticker);
    printf("   Interval: %s\n", interval);
    printf("   Tech: Apple Silicon / AMD Radeon + OpenCL\n");
    printf("   Expected speedup: 100-500x faster than CPU\n\n");
    
    // Load configuration
    Config config;
    load_config(interval, &config);
    
    // Load data from CSV
    char filename[256];
    char ticker_lower[64];
    strcpy(ticker_lower, ticker);
    for (char* p = ticker_lower; *p; p++) *p = tolower(*p);
    
    snprintf(filename, sizeof(filename), "data/%s_%s.csv", ticker_lower, interval);
    
    printf("üìÇ Loading data from %s...\n", filename);
    
    float *closes, *highs, *lows;
    long long *timestamps;
    int num_candles = load_csv(filename, &closes, &highs, &lows, &timestamps);
    
    if (num_candles < 0) {
        printf("\nüí° To fetch data, run:\n");
        printf("   cd ../c && python3 fetch_data.py %s %s 600\n\n", ticker, interval);
        return 1;
    }
    
    printf("   ‚úÖ Loaded %d candles\n\n", num_candles);
    
    printf("============================================================\n");
    printf("üîß Optimizing %s - SMART Search\n", ticker);
    printf("   Candles: %d | Auto-detecting GPU...\n", num_candles);
    printf("============================================================\n\n");
    
    // Generate parameter combinations
    printf("‚ö° Generating parameter combinations...\n");
    
    int num_combinations = 0;
    for (int fl = config.fast_length_low_min; fl <= config.fast_length_low_max; fl++) {
        for (int sl = config.slow_length_low_min; sl <= config.slow_length_low_max; sl++) {
            if (fl >= sl) continue;
            for (int fm = config.fast_length_med_min; fm <= config.fast_length_med_max; fm++) {
                for (int sm = config.slow_length_med_min; sm <= config.slow_length_med_max; sm++) {
                    if (fm >= sm) continue;
                    for (int fh = config.fast_length_high_min; fh <= config.fast_length_high_max; fh++) {
                        for (int sh = config.slow_length_high_min; sh <= config.slow_length_high_max; sh++) {
                            if (fh >= sh) continue;
                            for (int atr = config.atr_length_min; atr <= config.atr_length_max; atr++) {
                                for (int vol = config.volatility_length_min; vol <= config.volatility_length_max; vol++) {
                                    for (int lp = config.low_vol_percentile_min; lp <= config.low_vol_percentile_max; lp++) {
                                        for (int hp = config.high_vol_percentile_min; hp <= config.high_vol_percentile_max; hp++) {
                                            if (lp >= hp) continue;
                                            num_combinations++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    printf("   Total combinations: %d\n\n", num_combinations);
    
    // Initialize OpenCL
    cl_int err;
    cl_platform_id platform;
    clGetPlatformIDs(1, &platform, NULL);
    
    // Get all GPU devices and select the best one
    cl_uint num_devices;
    clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, NULL, &num_devices);
    cl_device_id* devices = malloc(num_devices * sizeof(cl_device_id));
    clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, num_devices, devices, NULL);
    
    // Smart device selection: Prefer Apple Silicon > Discrete GPU > Integrated GPU
    cl_device_id device = devices[0];
    char selected_device_name[128] = "";
    int device_priority = 0; // 0=integrated, 1=discrete, 2=Apple Silicon
    
    for (int i = 0; i < num_devices; i++) {
        char name[128];
        clGetDeviceInfo(devices[i], CL_DEVICE_NAME, sizeof(name), name, NULL);
        
        int priority = 0;
        if (strstr(name, "Apple M") || strstr(name, "Apple")) {
            priority = 2; // Apple Silicon (M1/M2/M3) - best performance
        } else if (strstr(name, "Radeon")) {
            priority = 1; // Discrete AMD GPU
        } else {
            priority = 0; // Integrated GPU (Intel UHD, etc)
        }
        
        if (priority > device_priority) {
            device = devices[i];
            device_priority = priority;
            strncpy(selected_device_name, name, sizeof(selected_device_name) - 1);
        }
    }
    free(devices);
    
    cl_context context = clCreateContext(NULL, 1, &device, NULL, NULL, &err);
    cl_command_queue queue = clCreateCommandQueue(context, device, 0, &err);
    
    // Get device info for optimization
    cl_ulong max_mem_alloc, global_mem;
    size_t max_work_group_size;
    cl_uint compute_units;
    clGetDeviceInfo(device, CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(cl_ulong), &max_mem_alloc, NULL);
    clGetDeviceInfo(device, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(cl_ulong), &global_mem, NULL);
    clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), &max_work_group_size, NULL);
    clGetDeviceInfo(device, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &compute_units, NULL);
    
    cl_program program = clCreateProgramWithSource(context, 1, &kernel_source, NULL, &err);
    clBuildProgram(program, 1, &device, "-cl-fast-relaxed-math", NULL, NULL);
    cl_kernel kernel = clCreateKernel(program, "optimize_strategy", &err);
    
    // Allocate and populate parameter array
    float* h_params = malloc(num_combinations * 10 * sizeof(float));
    int idx = 0;
    
    for (int fl = config.fast_length_low_min; fl <= config.fast_length_low_max; fl++) {
        for (int sl = config.slow_length_low_min; sl <= config.slow_length_low_max; sl++) {
            if (fl >= sl) continue;
            for (int fm = config.fast_length_med_min; fm <= config.fast_length_med_max; fm++) {
                for (int sm = config.slow_length_med_min; sm <= config.slow_length_med_max; sm++) {
                    if (fm >= sm) continue;
                    for (int fh = config.fast_length_high_min; fh <= config.fast_length_high_max; fh++) {
                        for (int sh = config.slow_length_high_min; sh <= config.slow_length_high_max; sh++) {
                            if (fh >= sh) continue;
                            for (int atr = config.atr_length_min; atr <= config.atr_length_max; atr++) {
                                for (int vol = config.volatility_length_min; vol <= config.volatility_length_max; vol++) {
                                    for (int lp = config.low_vol_percentile_min; lp <= config.low_vol_percentile_max; lp++) {
                                        for (int hp = config.high_vol_percentile_min; hp <= config.high_vol_percentile_max; hp++) {
                                            if (lp >= hp) continue;
                                            h_params[idx * 10 + 0] = fl;
                                            h_params[idx * 10 + 1] = sl;
                                            h_params[idx * 10 + 2] = fm;
                                            h_params[idx * 10 + 3] = sm;
                                            h_params[idx * 10 + 4] = fh;
                                            h_params[idx * 10 + 5] = sh;
                                            h_params[idx * 10 + 6] = atr;
                                            h_params[idx * 10 + 7] = vol;
                                            h_params[idx * 10 + 8] = lp;
                                            h_params[idx * 10 + 9] = hp;
                                            idx++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    float* h_results = malloc(num_combinations * 5 * sizeof(float));
    float* h_trade_log = calloc(300, sizeof(float)); // Max 100 trades * 3 floats
    
    // Create GPU buffers
    cl_mem d_closes = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, 
                                     num_candles * sizeof(float), closes, &err);
    cl_mem d_highs = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                    num_candles * sizeof(float), highs, &err);
    cl_mem d_lows = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                   num_candles * sizeof(float), lows, &err);
    cl_mem d_params = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                     num_combinations * 10 * sizeof(float), h_params, &err);
    cl_mem d_results = clCreateBuffer(context, CL_MEM_WRITE_ONLY,
                                      num_combinations * 5 * sizeof(float), NULL, &err);
    cl_mem d_trade_log = clCreateBuffer(context, CL_MEM_WRITE_ONLY,
                                        300 * sizeof(float), NULL, &err);
    
    // Set kernel arguments
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &d_closes);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &d_highs);
    clSetKernelArg(kernel, 2, sizeof(cl_mem), &d_lows);
    clSetKernelArg(kernel, 3, sizeof(int), &num_candles);
    clSetKernelArg(kernel, 4, sizeof(cl_mem), &d_params);
    clSetKernelArg(kernel, 5, sizeof(cl_mem), &d_results);
    clSetKernelArg(kernel, 6, sizeof(int), &num_combinations);
    clSetKernelArg(kernel, 7, sizeof(cl_mem), &d_trade_log);
    
    // Execute kernel
    printf("   Compute Units: %d | Max Work Group: %zu\n", compute_units, max_work_group_size);
    printf("   GPU Memory: %.2f GB\n\n", global_mem / (1024.0 * 1024.0 * 1024.0));
    
    // Optimize work group size based on device type
    size_t local_work_size;
    if (device_priority == 2) {
        // Apple Silicon - optimal for M1/M2/M3
        local_work_size = (max_work_group_size >= 1024) ? 1024 : max_work_group_size;
    } else if (device_priority == 1) {
        // Discrete GPU (Radeon) - optimal for AMD
        local_work_size = 256;
    } else {
        // Integrated GPU - conservative
        local_work_size = 128;
    }
    
    size_t global_work_size = num_combinations;
    if (global_work_size % local_work_size != 0) {
        global_work_size = ((global_work_size / local_work_size) + 1) * local_work_size;
    }
    
    struct timeval start, end;
    gettimeofday(&start, NULL);
    
    clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &global_work_size, &local_work_size, 0, NULL, NULL);
    clFinish(queue);
    
    gettimeofday(&end, NULL);
    double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / 1e6;
    
    // Read results
    clEnqueueReadBuffer(queue, d_results, CL_TRUE, 0, 
                        num_combinations * 5 * sizeof(float), h_results, 0, NULL, NULL);
    clEnqueueReadBuffer(queue, d_trade_log, CL_TRUE, 0,
                        300 * sizeof(float), h_trade_log, 0, NULL, NULL);
    
    // Find best result
    float best_score = -INFINITY;
    int best_idx = -1;
    int valid_count = 0;
    
    for (int i = 0; i < num_combinations; i++) {
        if (h_results[i * 5 + 4] > 0.5f) {
            valid_count++;
            if (h_results[i * 5 + 3] > best_score) {
                best_score = h_results[i * 5 + 3];
                best_idx = i;
            }
        }
    }
    
    double tests_per_sec = num_combinations / elapsed;
    
    printf("\n‚úÖ Optimization Complete\n");
    printf("   Tested: %d combinations\n", num_combinations);
    printf("   Valid: %d results\n", valid_count);
    printf("   Filtered: %d (early termination)\n", num_combinations - valid_count);
    printf("   Time: %.1fs (%.0f tests/sec)\n", elapsed, tests_per_sec);
    printf("   Avg time per test: %.3fms\n\n", (elapsed / num_combinations) * 1000.0);
    
    if (best_idx >= 0) {
        printf("üèÜ BEST PARAMETERS FOR %s\n\n", ticker);
        printf("üìä Performance Metrics:\n");
        printf("   Total Return: %.2f%%\n", h_results[best_idx * 5 + 0]);
        printf("   Max Drawdown: %.2f%%\n", h_results[best_idx * 5 + 1]);
        printf("   Calmar Ratio: %.2f\n", h_results[best_idx * 5 + 0] / h_results[best_idx * 5 + 1]);
        printf("   Total Trades: %.0f\n", h_results[best_idx * 5 + 2]);
        printf("   Score: %.2f\n\n", h_results[best_idx * 5 + 3]);
        
        printf("‚öôÔ∏è  Optimal Parameters:\n");
        printf("   Low Vol:  Fast=%.0f, Slow=%.0f\n", 
               h_params[best_idx * 10 + 0], h_params[best_idx * 10 + 1]);
        printf("   Med Vol:  Fast=%.0f, Slow=%.0f\n",
               h_params[best_idx * 10 + 2], h_params[best_idx * 10 + 3]);
        printf("   High Vol: Fast=%.0f, Slow=%.0f\n",
               h_params[best_idx * 10 + 4], h_params[best_idx * 10 + 5]);
        printf("   ATR Length: %.0f\n", h_params[best_idx * 10 + 6]);
        printf("   Volatility Lookback: %.0f\n", h_params[best_idx * 10 + 7]);
        printf("   Percentiles: Low=%.0f%%, High=%.0f%%\n",
               h_params[best_idx * 10 + 8], h_params[best_idx * 10 + 9]);
    }
    
    // Calculate Buy & Hold
    float buy_hold_return = ((closes[num_candles - 1] - closes[0]) / closes[0]) * 100.0f;
    float strategy_outperformance = h_results[best_idx * 5 + 0] - buy_hold_return;
    
    printf("\n============================================================\n");
    printf("üìà PERFORMANCE COMPARISON\n");
    printf("============================================================\n");
    printf("   Buy & Hold Return: %.2f%%\n", buy_hold_return);
    printf("   Strategy Outperformance: %.2f%%\n", strategy_outperformance);
    
    // Display trades from best parameter set
    printf("\n============================================================\n");
    printf("üìã TRADE LOG (Best Parameters)\n");
    printf("============================================================\n");
    int trade_count = 0;
    int entry_idx = -1;
    float entry_price = 0.0f;
    
    for (int i = 0; i < 100; i++) {
        int candle_idx = (int)h_trade_log[i * 3 + 0];
        float price = h_trade_log[i * 3 + 1];
        int is_buy = (int)h_trade_log[i * 3 + 2];
        
        if (candle_idx == 0 && price == 0.0f) break; // End of trades
        
        // Convert timestamp to readable date/time
        time_t ts = (time_t)timestamps[candle_idx];
        struct tm *tm_info = localtime(&ts);
        char date_str[64];
        strftime(date_str, sizeof(date_str), "%Y-%m-%d %H:%M", tm_info);
        
        if (is_buy) {
            printf("   #%d  BUY  @ $%.2f on %s\n", ++trade_count, price, date_str);
            entry_idx = candle_idx;
            entry_price = price;
        } else {
            float pnl = ((price - entry_price) / entry_price) * 100.0f;
            printf("   #%d  SELL @ $%.2f on %s | P&L: %s%.2f%%\n", 
                   ++trade_count, price, date_str,
                   pnl >= 0 ? "+" : "", pnl);
        }
    }
    printf("   Total trades: %d\n", trade_count);
    
    printf("\n============================================================\n");
    printf("üìä OPTIMIZATION COMPLETE\n");
    printf("============================================================\n\n");
    
    // Cleanup
    clReleaseMemObject(d_closes);
    clReleaseMemObject(d_highs);
    clReleaseMemObject(d_lows);
    clReleaseMemObject(d_params);
    clReleaseMemObject(d_results);
    clReleaseMemObject(d_trade_log);
    clReleaseKernel(kernel);
    clReleaseProgram(program);
    clReleaseCommandQueue(queue);
    clReleaseContext(context);
    
    free(closes);
    free(highs);
    free(lows);
    free(timestamps);
    free(h_params);
    free(h_results);
    free(h_trade_log);
    
    return 0;
}
